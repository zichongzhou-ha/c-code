## 字符串函数及模拟实现

### strlen
```
#include<stdio.h>
#include<string>
#include<cassert>
//strlen 的函数放回值是size_t:unsigned int,这也意味着会出现一些比较有趣的地方
int my_strlen(const char* str)//注意细节：const
{
	int cnt = 0;
	assert((str != NULL));

	while (*str != '\0')
	{
		str++;
		cnt++;
	}
	return cnt;
}
int main()
{
	const char* arr1 = "hello";
	const char* arr2 = "hh";
	printf("%d\n", strlen(arr2) - strlen(arr1));
	printf("%u\n", strlen(arr2) - strlen(arr1));
	printf("%zu\n", strlen(arr2) - strlen(arr1));
	return 0;
}

```


### strcpy
- 使用：
	1. 源字符串必须以'\0'结束。
	2. 会将源字符串中的'\0'拷贝到目标空间。
	3. 目标空间必须足够大，以确保能存放源字符串。
	4. 目标空间必须可变
	```
	int main()
	{
		const char* arr = "hello world";
		const char* brr = "haha";
		strcpy(arr,brr)//报错，arr空间不可变
		return 0;
	}
	```
- 模拟实现
```
#include<stdio.h>
#include<string.h>
#include<cassert>
char* my_strcpy(char* dest, const char* src)
{
	assert(dest && src);
	char* ret = dest;
	while(*dest++=*src++){}
	return ret;
}

```
### strcat
- 字符串追加(连接)
```
#include<stdio.h>
#include<string>
int main()
{
	char arr[20] = "hello \0 ##########";
	char s[] = "world";
	strcat(arr, s);
	printf("%s\n", arr);
	return  0; 
}//结果：hello world
```
- 源字符串必须以'\0'结束
- 目标空间必须有足够大，能容纳下源字符串的内容。
- 目标空间必须可修改
- strcat的模拟实现
```
#include<stdio.h>
#include<string>
char* my_strcat(char* dest, const char* src)
{
	char* ret = dest;
	while(*dest){
		dest++;
	}
	while(*dest++=*src++){}//在 C/C++ 中，赋值表达式的值等于赋值后左操作数的值
	return ret;
}


```
- 能不能自己给自己追加-》不能！把自己的\0覆盖了

### strcmp
- 字符串比较：比的是ASCII码，前者大于后者--》返回>0
- 函数模拟：
```
int my_strcmp(const char*s1,const char* s2)
{
	assert(s1&&s2);
	while(*s1==*s2)
	{
		if(*s1=='\0')
		return 0;
		s1++;
		s2++;
	}
	<!-- if(*s1>*s2)
	{
		return 1;
	}
	else return -1; -->
	return *s1-*s2;
}
```

**以上都是长度不受限制的字符串函数**
- strncpy
	1. 拷⻉num个字符从源字符串到⽬标空间
	2. 如果源字符串的⻓度⼩于num，则拷⻉完源字符串之后，在⽬标的后边追加0，直到num个

- strncat
	1. 将source指向字符串的前num个字符追加到destination指向的字符串末尾，再追加⼀个 \0 字符
	2. 如果source指向的字符串的⻓度⼩于num的时候，只会将字符串中到\0 的内容追加到destination指向的字符串末尾
- strncmp
- 这里其实要关注的是安全性问题(strcat会安全一丢丢)
```
#include <stdio.h>
#include<string>
int main()
{
	char arr[20] = "hello";
	char brr[10] = "word89796";
	strncpy(arr + 5, brr, 5);
	printf("%s\n", arr);
	return 0;
}
```
- 这个程序一开始没保错，我还纳闷，不是说brr的字符数>5,拷贝过去不会带\0吗，怎么还不报错，后来细看了，原来是arr太大了点，后面已经有很多\0了，改小后果然就报错了
- strcat说比它安全点就是总会加个\0上去，但我觉得没啥不一样，因为它们要是目标空间不够都会报错
```
#include <stdio.h>
#include<string>
int main()
{
	char arr[8] = "hello";//
	char brr[10] = "word89796";
	strncat(arr+5, brr, 5);
	printf("%s\n", arr);
	return 0;
}
```
- 一开始我觉得这个能安全的，因为它会加\0嘛，结果想多了，arr空间不够，真绝了，我要是把5改小点实际上arr后面本来就有\0看不出安全问题，改大点就是空间问题，所以这个机制下就是得全方面考虑它们的安全。

### strstr
- 在字符中查找指定字符
- 基本使用：
```
#include <stdio.h>
#include<string>
int main()
{
	char arr[] = "hellodsf";
	char brr[] = "llo";
	char* tmp = strstr(arr, brr);
	if (tmp != NULL)
	{
		printf("%s\n", tmp);//打印出：llodsf，返回的是首个字符的地址
	}
	return 0;
}
```

- 模拟实现：
```
char* my_strstr(const char* str1,const char* str2)
{
	assert(str1 && str2);
	const char* s1 = NULL;
	const char* s2 = NULL;
	const char* cp = str1;
	if (*str2 == '\0')
	{
		return  (char*)str1;
	}
	while (*cp)
	{
		s1 = cp;
		s2 = str2;
		while (*s1 && *s2 && (*s1++ == *s2++)){}
		if (*s2 == '\0')
		{
			return (char*)cp;
		}
		cp++;
	}
	return NULL;
}
```

### strtok
- char * strtok ( char * str, const char * sep);
- sep参数指向⼀个字符串，定义了⽤作分隔符的字符集合
- 第⼀个参数指定⼀个字符串，它包含了0个或者多个由sep字符串中⼀个或者多个分隔符分割的标
记。
- strtok函数找到str中的下⼀个标记，并将其⽤ \0 结尾，返回⼀个指向这个标记的指针。（注：
strtok函数会改变被操作的字符串，所以被strtok函数切分的字符串⼀般都是临时拷⻉的内容并且
可修改。）
- strtok函数的第⼀个参数不为 NULL ，函数将找到str中第⼀个标记，strtok函数将保存它在字符串
中的位置。
- strtok函数的第⼀个参数为 NULL ，函数将在同⼀个字符串中被保存的位置开始，查找下⼀个标
记。
- 如果字符串中不存在更多的标记，则返回 NULL 指针。


- 使用：
```
#include <stdio.h>
#include<string>
#include<cassert>
int main()
{
	char arr[] = "sd@sldf.Dfls";
	const char* p = "@.";
	char tmp[20];
	strcpy(tmp, arr);
	char* ret = NULL;
	<!-- ret= strtok(tmp, p);
	printf("%s\n", ret);//sd

	ret = strtok(NULL, p);
	printf("%s\n", ret);//sldf

	ret = strtok(NULL, p);
	printf("%s\n", ret);//Dfls

	ret = strtok(NULL, p);
	printf("%s\n", ret);//NULL -->
	for(ret=strtok(tmp,p);ret!=NULL;ret=strtok(NULL,p))
	{
		printf("%s\n", ret);
	}
	return 0;
}
``` 

### strerror

- 在不同的系统和C语⾔标准库的实现中都规定了⼀些错误码，⼀般是放在 errno.h 这个头⽂件中说明
的，C语⾔程序启动的时候就会使⽤⼀个全局的变量errno来记录程序的当前错误码，只不过程序启动
的时候errno是0，表⽰没有错误，当我们在使⽤标准库中的函数的时候发⽣了某种错误，就会将对应
的错误码，存放在errno中，⽽⼀个错误码的数字是整数很难理解是什么意思，所以每⼀个错误码都是
有对应的错误信息的。strerror函数就可以将错误对应的错误信息字符串的地址返回。
- 使用
```
#include<stdio.h>
#include<errno.h>
#include<string>
int main()
{
	FILE* pf = fopen("log.txt", "r");//文件不存在，打开失败
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));//No such file or directory
		perror("fopen");//fopen: No such file or directory,等同于这个函数，自己拿取errno去打印

	}
	/*fclose(pf);
	pf = NULL;*///加这句话直接异常，因为close的文件是NULL;

	return 0;
}
```
